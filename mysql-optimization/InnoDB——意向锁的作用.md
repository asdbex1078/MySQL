> innodb的意向锁有什么作用？
> mysql官网上对于意向锁的解释中有这么一句话
> “The main purpose of IX and IS locks is to show that someone is locking a row, or going to lock a row in the table.”
> 意思是说加意向锁的目的是为了表明某个事务正在锁定一行或者将要锁定一行。
> 那么，意向锁的作用就是“表明”加锁的意图，可是为什么要表明这个 意图呢？
> 如果仅仅锁定一行仅仅需要加一个锁，那么就直接加锁就好了，这里要表明加锁意图的原因是因为要锁定一行不仅仅是要加一个锁，而是要做一系列操作吗？
>
> 
>
> 作者：尹发条地精 https://www.zhihu.com/question/51513268 

我最近也在看这个，我说一下我的理解

1. 在mysql中有表锁，LOCK TABLE my_tabl_name READ;  用读锁锁表，会阻塞其他事务修改表数据。LOCK TABLE my_table_name WRITe; 用写锁锁表，会阻塞其他事务读和写。

2. Innodb引擎又支持行锁，行锁分为共享锁，一个事务对一行的共享只读锁。排它锁，一个事务对一行的排他读写锁。

3. 这两中类型的锁共存的问题考虑这个例子：
   事务A锁住了表中的一行，让这一行只能读，不能写。之后，事务B申请整个表的写锁。如果事务B申请成功，那么理论上它就能修改表中的任意一行，这与A持有的行锁是冲突的。
   数据库需要避免这种冲突，就是说要让B的申请被阻塞，直到A释放了行锁。

   

数据库要怎么判断这个冲突呢？

step1：判断表是否已被其他事务用表锁锁表
		step2：判断表中的每一行是否已被行锁锁住。

注意step2，这样的判断方法效率实在不高，因为需要遍历整个表。
于是就有了意向锁。在意向锁存在的情况下，事务A必须先申请表的意向共享锁，成功后再申请一行的行锁。在意向锁存在的情况下，
上面的判断可以改成

step1：不变
		step2：发现表上有意向共享锁，说明表中有些行被共享行锁锁住了，因此，事务B申请表的写锁会被阻塞。

注意：申请意向锁的动作是数据库完成的，就是说，事务A申请一行的行锁的时候，数据库会自动先开始申请表的意向锁，不需要我们程序员使用代码来申请。

总结：为了实现多粒度锁机制（白话：为了表锁和行锁都能用）